import eina_types;

struct Efl.Ui.Dnd_Event {
   [[Event struct that contains information about what is avaiable at which position, in which seat]]
   position : Eina.Position2D; [[The position of the Drop event]]
   seat : uint; [[In which seat it is happening]]
   available_types : accessor<string>; [[which types are avaiable, you should use one of these for a call to @Efl.Ui.Dnd.drop_data_get ]]
}

struct Efl.Ui.Dnd_Drop_Event {
   dnd : Efl.Ui.Dnd_Event; [[The overall information]]
   action : string; [[The action the client should take]]
}

mixin @beta Efl.Ui.Dnd requires Efl.Object {
   methods {
      drag_start {
         [[Start a drag from this client.

           @[Efl.Ui.Dnd.drag,start] will be emitted each time a successfull drag will be started.
           @[Efl.Ui.Dnd.drag,finished] will be emitted every time a drag is finished.
         ]]
         params {
            content : Eina.Content @by_ref; [[The content you want to provide via dnd]]
            @in action: string; [[Action when data is transferred]]
            @in seat: uint; [[Specified seat for multiple seats case.]]
         }
         return : Efl.Content; [[A UI element where you can just set your visual representation into]]
      }
      drag_cancel {
         [[Cancel the on-going drag]]
         params {
            @in seat: uint; [[Specified seat for multiple seats case.]]
         }
      }
      drop_data_get {
         [[Get the data from the object that has selection]]
         params {
           seat : uint;  [[Specified seat for multiple seats case.]]
           acceptable_types : iterator<string>; [[The types that are acceptable for you]]
         }
         return : future<Eina.Content> @move; [[fullfilled when the content is transmitted, and ready to use]]
      }
   }
   events {
      drop,enter : Efl.Ui.Dnd_Event;
      drop,leave : Efl.Ui.Dnd_Event;
      drop,pos : Efl.Ui.Dnd_Event;
      drop,drop : Efl.Ui.Dnd_Drop_Event;
      drag,start : void;
      drag,finished : bool;
   }
   implements {
      Efl.Object.constructor;
      Efl.Object.invalidate;
      Efl.Object.finalize;
   }
}
